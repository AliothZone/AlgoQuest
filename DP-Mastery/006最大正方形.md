##　[221\. 最大正方形](https://leetcode.cn/problems/maximal-square/)

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1：**

![](vx_images/396554730445605.jpg)

**输入：**matrix = \[\["1","0","1","0","0"\],\["1","0","1","1","1"\],\["1","1","1","1","1"\],\["1","0","0","1","0"\]\]
**输出：**4

**示例 2：**

![](vx_images/390515846548487.jpg)

**输入：**matrix = \[\["0","1"\],\["1","0"\]\]
**输出：**1

**示例 3：**

**输入：**matrix = \[\["0"\]\]
**输出：**0

**提示：**

*   `m == matrix.length`
*   `n == matrix[i].length`
*   `1 <= m, n <= 300`
*   `matrix[i][j]` 为 `'0'` 或 `'1'`

**解法**
这个问题涉及矩阵中寻找最大正方形的问题，通常被称为“最大正方形问题”。在给定一个包含 0 和 1 的二维矩阵时，任务是找出最大的正方形区域，其中所有元素都是 1。

一种常见的解法是通过动态规划（Dynamic Programming, DP）来求解。我们可以使用一个二维 DP 数组来表示以当前位置为右下角的最大正方形的边长。

**动态规划思想**

1. **状态定义**：定义 `dp[i][j]` 表示以 `(i, j)` 为右下角的最大正方形的边长。

2. **状态转移方程**：
   - 如果当前位置 `matrix[i][j]` 为 0，那么 `dp[i][j] = 0`，因为不能形成正方形。
   - 如果当前位置 `matrix[i][j]` 为 1，且它的上面、左边、以及左上角的位置也能够构成正方形，那么可以扩展形成一个新的正方形。因此：
     \[
     dp[i][j] = \min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
     \]
     这个公式表示，当前位置 `(i, j)` 为 1 时，可以从它上面、左边、左上角的最小正方形边长来扩展一个新正方形，边长加 1。

3. **初始化**：
   - 如果 `matrix[i][j]` 为 1 并且处在矩阵的第一行或第一列时，`dp[i][j]` 的值就是 1，因为它只能构成一个边长为 1 的正方形。

4. **最终结果**：
   - 最终的最大正方形的边长就是 `dp` 数组中的最大值。

**代码实现**

```cpp
#include <vector>
#include <algorithm>
using namespace std;

int maximalSquare(vector<vector<char>>& matrix) {
    if (matrix.empty() || matrix[0].empty()) return 0;

    int m = matrix.size();
    int n = matrix[0].size();
    vector<vector<int>> dp(m, vector<int>(n, 0));
    int maxSide = 0;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (matrix[i][j] == '1') {
                if (i == 0 || j == 0) {
                    dp[i][j] = 1;  // 第一行或第一列，正方形边长只能为 1
                } else {
                    dp[i][j] = min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}) + 1;
                }
                maxSide = max(maxSide, dp[i][j]);  // 更新最大边长
            }
        }
    }

    return maxSide * maxSide;  // 返回最大正方形的面积
}
```

- **时间复杂度**：`O(m * n)`，其中 `m` 是矩阵的行数，`n` 是矩阵的列数。我们需要遍历整个矩阵并计算每个位置的 `dp` 值。
- **空间复杂度**：`O(m * n)`，用于存储 DP 数组。

通过动态规划的方法，我们可以有效地找到矩阵中包含全为 1 的最大正方形的面积。在实现中，关键是要通过状态转移方程更新每个位置的 `dp` 值，最终得出最大正方形的面积。